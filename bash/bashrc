# Shell is non-interactive. Be done now!
if [[ $- != *i* ]]; then
    return
fi


HISTSIZE=200000
#HISTFILESIZE=20000

# \[ \] to indicate a special string amid them.
black=$'\[\e[1;30m\]'
red=$'\[\e[1;31m\]'
green=$'\[\e[1;32m\]'
yellow=$'\[\e[1;33m\]'
blue=$'\[\e[1;34m\]'
magenta=$'\[\e[1;35m\]'
cyan=$'\[\e[1;36m\]'
white=$'\[\e[1;37m\]'
normal=$'\[\e[m\]'

#black=$'\e[1;30m'
#red=$'\e[1;31m'
#green=$'\e[1;32m'
#yellow=$'\e[1;33m'
#blue=$'\e[1;34m'
#magenta=$'\e[1;35m'
#cyan=$'\e[1;36m'
#white=$'\e[1;37m'
#normal=$'\e[m'

unexport_cmds=("has_cmd" "_gen_add_path")

has_cmd() {
    hash "$1" &> /dev/null
    return $?
}

has_cmd dircolors && {
    [ -r ~/.dircolors ] && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls -F --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
    alias sdcv='sdcv --color'
}
alias tree='tree -F -C --charset=ascii'
alias ll='ls -hl'
alias la='ls -A'
alias l='ls -CF'
alias v='vim'
alias py='ipython'
has_cmd bat && alias cat='bat'
has_cmd proxychains && alias ldcv='proxychains -q ldcv'

alias gd='git diff -w'
alias gdm='git diff -w master'
alias gma='git commit -a'
alias gmaa='git commit -a --amend'


clip() {
    # clip [pattern] [file]
    if [[ -e "$1" ]]; then
        xclip -selection clipboard -i "$1"
    else
        # a small trick: $2 without quote if no argument given then put
        #                nothing as STDIN
        sed -n "$1p" $2 | xclip -selection clipboard
    fi
}

rm() {
    local trash="/tmp/.rm.trash"
    mkdir -p $trash
    for f in "$@"; do
        suffix="$(md5sum <(ls -ld "$f") | cut -d' ' -f1).$(date +%F_%H%M%S).bak"
        #echo "rm $f"
        mv "$f" "$trash/${f##*/}.$suffix"
    done
}

alias rm!='/bin/rm'

empty-trash() {
    local trash="/tmp/.rm.trash"
    rm! -rf $trash/*
}

host=''
if [[ "$(grep -o '(.*)' <(who -m))" != "" ]]; then
    host="$(hostname) "
fi
prompt_color="$white"
if [[ 0 == $(id -u) ]]; then
    prompt_color="$red"
fi

gen_short_workpath() {
    local short_workspace=''
    local dir="$PWD"
    if [[ "$dir" == "/" ]]; then
        echo "/"
        return
    fi
    if [[ $dir == ${HOME}* ]]; then
        short_workspace="~"
        dir=${dir#${HOME}}
    fi
    local SAVEIFS="$IFS"
    IFS=$'\n\b'
    local tmp=(${dir//\//$'\n'})
    local lastidx=$((${#tmp[@]}-1))
    if [[ $lastidx -lt 0 ]]; then
        IFS="$SAVEIFS"
        echo "$short_workspace"
        return
    fi
    dir=""
    for ((i = 0; i < lastidx; ++i)); do
        dir="${dir}/$(grep -Po '^\.*[^/]?' <<< ${tmp[$i]})"
    done
    dir="${dir}/${tmp[$lastidx]}"
    short_workspace=$short_workspace$dir
    IFS="$SAVEIFS"
    echo "$short_workspace"
}

find_git_branch () {
    local git_branch=''
    local dir=. head
    until [[ "$dir" -ef / ]]; do
        if [[ -r "$dir/.git/HEAD" ]]; then
            local head=$(< "$dir/.git/HEAD")
            if [[ $head = ref:\ refs/heads/* ]]; then
                git_branch="(${head#*/*/})"
            elif [[ $head != '' ]]; then
                git_branch="((detached))"
            else
                git_branch="((unknow))"
            fi
            echo $git_branch
            return
        fi
        dir="../$dir"
    done
}

# improve command cd through `lcsfind`
# that is a lua script implemented by lcs algorithm.
cd() {
    if [[ $# -lt 1 ]]; then
        builtin cd
        return $?
    fi
    ! which lcsfind &> /dev/null && {
        builtin cd "$1"
        return $?
    }
    local SAVEIFS="$IFS"
    IFS=$'\n\b'
    local wks="$PWD"
    [ '/' == "${1:0:1}" ] && wks=""
    local dir=(${1//\//$'\n'})
    for ((i = 0; i < ${#dir[@]}; ++i)); do
        local pat=${dir[i]}
        local cddirs=()
        local idx=0
        for j in $(\ls -a $wks/ 2> /dev/null); do
            [ -d "$wks/$j" ] && {
                [ "." == "${pat:0:1}" -a "." == "${j:0:1}" ] && {
                    cddirs[$idx]="$j"
                }
                [ "." != "${j:0:1}" ] && {
                    cddirs[$idx]="$j"
                }
            }
            ((idx = idx + 1))
        done
        if [[ $idx -lt 1 ]]; then
            echo "cd: $1: No matchable directory or path"
            return 1
        fi
        wks="$wks/$(lcsfind $pat "${cddirs[@]}")"
    done
    builtin cd "$wks/"
    IFS="$SAVEIFS"
    return $?
}

alias r='builtin cd /'          # '/' can't be as a command name and is instead of 'r'.
alias ..='builtin cd ..'
#alias ...='builtin cd ../..'
#alias 4.='builtin cd ../../../' # we can define more as command 'n.' to implement cd parent directories.

HISTTIMEFORMAT="%y-%m-%d %T "
# vi mode
# The implement of clearing screan by 'ctrl+l' is in file ~/.inputrc
set -o vi
# enable core, 10MB = 20480 blocks
ulimit -c 20480

has_cmd chez-scheme && alias scheme='chez-scheme'
has_cmd bc && alias bc='bc -lq'

_add_path() {
    local VAR=$1
    local d="$2"
    shift 2
    eval "local path=\"$d\$$VAR$d\""
    for i in $@; do
        case "$path" in
            *"$d$i$d"*) :;; # already here
            *) eval "$VAR=\"\$$VAR$d$i\"";;
        esac
    done
}

_gen_add_path() {
    # a little Meta Programming in Bash
    local funcs=("add-path      PATH        :"
                 "lua_add-path  LUA_PATH    ;"
                 "lua_add-cpath LUA_CPATH   ;")
    for func in "${funcs[@]}"; do
        local func=($func)
        eval "${func[0]}() {
            _add_path ${func[1]} \"${func[2]}\" \$@
        }"
    done
}
_gen_add_path

dump-path() {
    echo "list order of searching"
    echo "======================="
    echo "${PATH//:/$'\n'}"
}

# Add other rocks tree: $HOME/.local
has_cmd lua && {
    alias luai='lua -e "package.path=package.path..\";$HOME/.config/init.lua\"" -i -linit'
    LUA_VERSION=$(lua -e 'print(_VERSION:match("%d.%d"))')
    LUA_PATH=$(lua -e 'print(package.path)')
    LUA_CPATH=$(lua -e 'print(package.cpath)')
    lua_add-path  "$HOME/.local/share/lua/$LUA_VERSION/?.lua"
    lua_add-path  "$HOME/.local/share/lua/$LUA_VERSION/?/init.lua"
    lua_add-cpath "$HOME/.local/lib/lua/$LUA_VERSION/?.so"

    export LUA_PATH LUA_CPATH
}

# Binaries of Python package for this user
add-path "$HOME/.local/bin"
# Binaries of Ruby gem for this user
has_cmd ruby && {
    RUBY_VERSION=$(ruby -v | grep -o '[[:digit:]]\.[[:digit:]]\.[[:digit:]]')
    add-path "$HOME/.gem/ruby/$RUBY_VERSION/bin"
}

export PYTHONSTARTUP=~/.config/init.py
[[ $MAKEFLAGS != *-j4* ]] && export MAKEFLAGS+='-j4'
# enable 256colors
export TERM=xterm-256color
# PROMPT_COMMAND is invoked before displaying PS1
#PROMPT_COMMAND="gen_short_workpath; $PROMPT_COMMAND"
export PS1="$cyan\$host\$(gen_short_workpath)$yellow\$(find_git_branch)$prompt_color\\$ $normal"
export PS4="+$cyan\${BASH_SOURCE##*/}$normal:$red\$LINENO$normal: "

for fun in "${unexport_cmds[@]}"; do
    eval "unset $fun"
done
unset unexport_cmds

[[ -r ~/.environment ]] && source ~/.environment

# Own shell scripts. #tools-tag
add-path "/home/ltk/.dotfiles/tools/bin" #tools-tag
